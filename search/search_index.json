{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"HTMX Router","text":"<p>A lightweight file based router built on vite+htmx for SSR generation of full pages and html partials</p> <p>Features:</p> <ul> <li>BYO jsx templating</li> <li>File base routing</li> <li>Typesafe url path parameters</li> <li>Dynamic route fallthrough</li> <li>Server + Client Islands</li> <li>Route-less points</li> <li>CSS sheet generation</li> <li>html, opengraph, and json+ld metadata generation</li> <li>Bundle splitting for filtering out server code from the client</li> <li>Server-Side EventSource creation for SSE event dispatch</li> </ul>"},{"location":"api/","title":"API","text":"<p>The library is intentionally broken up into multiple files so that you can import only the part you need where you need it to help prevent server side features from being leaked to the client just because you wanted to use one of <code>htmx-router</code>'s apis on the client.</p> Feature Package Description Server Client Cookies <code>htmx-router/cookies</code> Request/Response cookie helper with client-side <code>document.cookie</code> support \u2611\ufe0f \u2611\ufe0f CSS <code>htmx-router/css</code> CSS sheet builder with name collision prevention \u2611\ufe0f - Defer <code>htmx-router/defer</code> End-to-end type-safe html partial loading \u2611\ufe0f - Endpoint <code>htmx-router/endpoint</code> Define a new endpoint without making a whole new route \u2611\ufe0f - Server Side Event <code>htmx-router/event-source</code> Helper for creating the sse for an EventSource \u2611\ufe0f - Navigate <code>htmx-router/navigate</code> Some helpers for client side htmx actions - \u2611\ufe0f Response <code>htmx-router/response</code> Helpers to render typed json responses, and trigger client side navigation and revalidation \u2611\ufe0f \u2611\ufe0f Shell <code>htmx-router/shell</code> Helpers to generate: html, opengraph, and json+ld meta-tags \u2611\ufe0f -"},{"location":"api/cookie/","title":"Cookie API","text":"<pre><code>import { Cookies, CookieOptions } from \"htmx-router/cookies\";\n</code></pre> <p>You can either give the <code>Cookies</code> class a string, or whole document object to read from. When given a <code>document</code> object it will go into client mode, and when setting cookies it will change them in the browser as well. To prevent this behaviour, provide <code>document.cookies</code> instead of the whole <code>document</code> object.</p> <pre><code>import { Cookie } from \"htmx-router/css\";\n\nconst local = new Cookies(document.cookie);\nlocal.set(\"key\", \"value\"); // changed document.cookie\n\nlet res: Response; // assume it exists\nconst external = new Cookie(res.headers.get(\"cookie\"));\nlocal.set(\"foo\", \"bar\");\n\nconst delta = local.export(); // array of Set-Cookie headers to make the changes\n</code></pre>"},{"location":"api/css/","title":"CSS API","text":"<p>When creating a new style you must give it a css save class name, however this value does not need to be unique, as the name will have a hash appended to it based on the style itself, so the only name collision that will occur is when you use the same name with the same definition which just a duplicate definition.</p> <p>Since the name of the class will be mutated, in your source you should refer to it as <code>.this</code> which will be replaced by the mutated name. <pre><code>import { Style } from \"htmx-router/css\";\n\nconst myStyle = new Style(\"myStyle\", `\n.this {\n  background-color: red;\n}\n\n.this button {\n  background-color: blue;\n}`);\n</code></pre></p> <p>Then to use the style simply refer to it's name <pre><code>&lt;div class={myStyle.name}&gt;\n  I am red\n  &lt;button&gt;I am blue&lt;/button&gt;\n&lt;/div&gt;\n</code></pre></p> <p>These styles must be defined at the top level of your file for them to be included in the generated style sheet. If you create a new style on request, or at a later point in time, it may not be included in the CSS bundled provided to the client.</p> <p>To import the generated style sheet on the client use the <code>&lt;Scripts&gt;</code> component which will do this automatically. Or you can do it manually via: <pre><code>import { GetSheetUrl } from \"htmx-router/css\";\n&lt;link href={GetSheetUrl()} rel=\"stylesheet\"&gt;&lt;/link&gt;\n</code></pre></p>"},{"location":"api/defer/","title":"Defer API","text":"<p>A deferral is a type-safe endpoint designed for lazy loading of dynamic content on a static page, but can also be repurposed for loading html partials for htmx updates.</p> <p>Before using a deferral you should first register it, or else the type safety will not be in place. When registering a function you must define which functions to use to convert from the raw strings to the types you want to use. This behaves identically to route parameters.</p> <p>You optionally can define an extra object for going from the types back to strings for the original network call.</p> Registering a Deferral<pre><code>import { Deferral, RegisterDeferral } from \"htmx-router/defer\";\n\nconst lazyCardParameters = {\n  kind: (s: string) =&gt; {\n    if (s !== \"yes\" &amp;&amp; s !== \"no\") throw new Error(\"bad kind\")\n    return s;\n  }\n  id: Number\n}\nRegisterDeferral(lazyCardParameters, LazyCard, { kind: String, id: String });\nfunction LazyCard({}: RouteContext&lt;typeof&gt;) { /**/ }\n</code></pre> <p>Once defined you can either use it directly in a <code>&lt;Defer&gt;</code> <pre><code>&lt;Defer loader={LazyCard} params={{ kind: \"yes\", id: 420 }}&gt;loading...&lt;/Defer&gt;\n</code></pre></p> <p>Or you can get the URL for htmx use <pre><code>&lt;div hx-get={Deferral(LazyCard, { kind: \"no\", id: 69 })}&gt;&lt;/div&gt;\n</code></pre></p>"},{"location":"api/endpoint/","title":"Endpoint API","text":"<p>This allows you to create a new endpoint with complete control over it for all methods and query strings, however it cannot use url parameters, and because it's query parameters aren't controlled by the router, their type safety must be done manually unlike defer.</p> <pre><code>import { Endpoint } from \"htmx-router/endpoint\";\n\nconst endpoint = new Endpoint(({}: RouteContext) =&gt; {\n  return text(\"hello world\");\n});\n\n// fetch(endpoint.url);\n</code></pre>"},{"location":"api/event-source/","title":"EventSource API","text":"<p>The goal of these helpers is to be as close as possible to the client EventSource, however it needs to diverge since the javascript API is receive only, but the server needs to send data.</p> <p>When it's being created you must give it the request object, and you can optionally defined how often keep-alive pulsed should be sent (defaults to 30sec). <pre><code>import { EventSource } from \"htmx-router/event-source\";\n\nexport function loader({ request, render }: RouteContext) {\n  const source = new EventSource&lt;true&gt;(request, render);\n\n  const timer = setInterval(() =&gt; {\n    source.dispatch(\"message\", &lt;b&gt;hello everyone&lt;/b&gt;);\n    if (source.readyState === 2) { // the source has been closed\n      clearInterval(timer);\n    }\n  }, 1000);\n\n  return source.response();\n}\n</code></pre></p> <p>An <code>EventSource</code> will also auto close when the server receives a <code>SIGTERM</code> or <code>SIGHUP</code> so it can gracefully shutdown.</p> <p>There is also a <code>EventSourceSet</code> which is designed for pooling streams to send the same live information to multiple connections. <code>EventSource</code>s will be auto removed from the set if it is closed when a <code>.dispatch</code> is issued. <pre><code>import { EventSource, EventSourceSet } from \"htmx-router/event-source\";\n\nconst group = new EventSourceSet();\nsetInterval(() =&gt; {\n  group.dispatch(\"message\", \"hello everyone\");\n}, 1000);\n\nexport function loader({ request }: RouteContext) {\n  const source = new EventSource(request);\n  group.add(source);\n\n  return source.response();\n}\n</code></pre></p> <p>Note using <code>group.delete()</code> or <code>group.clear()</code> will not close the connection, instead just removing them from the group. This means you will need to manually close the source when you delete it from the set, and use <code>group.closeAll()</code>.</p>"},{"location":"api/event-source/#tips","title":"Tips","text":"<p>Combining this with htmx sse can allow you to stream live data to multiple clients at once, or create your own pool of sources which manages which user has a lock on something, and on an interval you send a lock icon down for if they do or do not have the lock. Then when the dispatch fails you unlock the entity from that user since the connection was closed. Then you don't have to rely on your client successfully sending a beacon when the window is closed to free the lock.</p>"},{"location":"api/navigate/","title":"Navigate API","text":"<pre><code>import { navigate, revalidate, htmxAppend } from \"htmx-router/navigate\";\n</code></pre> <p>These functions are just client side helpers for getting some common htmx calls you might make from a front-end framework.</p>"},{"location":"api/navigate/#navigate","title":"Navigate","text":"<pre><code>async function navigate(href: string, pushUrl = true)\n</code></pre> <p>Takes the href you want to navigate, if the href is part of the same domain it will do a htmx boost to that page, otherwise it will do a full page reload to that location.</p> <p><code>pushUrl</code> defines whether or not the navigation should be added the browser's history.</p>"},{"location":"api/navigate/#revalidate","title":"Revalidate","text":"<pre><code>async function revalidate()\n</code></pre> <p>A short cut to <code>navigate()</code> to the current location effectively revalidating the current page.</p>"},{"location":"api/navigate/#htmxappend","title":"htmxAppend","text":"<pre><code>async function htmxAppend(href: string, verb = \"GET\")\n</code></pre> <p>Will load the href and append the html response to the end of the body. This is useful for server side dialogs</p>"},{"location":"api/response/","title":"Response API","text":"<p>The response function are mostly just helpers to ensure things like response JSON objects with a bad status aren't caught by a shell's error catcher.</p>"},{"location":"api/response/#text","title":"text","text":"<p>For returning plain text as a response <pre><code>import { text } from \"htmx-router/response\";\nconst r: Response = text( \n  \"bad request\",\n  { statusText: \"bad request\", status: 400 }\n);\n</code></pre></p>"},{"location":"api/response/#text_1","title":"text","text":"<p>For returning plain html as a response without it being caught by an <code>error</code> function <pre><code>import { html } from \"htmx-router/response\";\nconst r: Response = html( \n  \"&lt;html&gt;....&lt;/html&gt;\",\n  { statusText: \"bad request\", status: 400 }\n);\n</code></pre></p>"},{"location":"api/response/#json","title":"json","text":"<p>For returning a json object as a response with type information <pre><code>import { json } from \"htmx-router/response\";\nconst r: Response = json(\n  { error: \"bad request\" },\n  { statusText: \"bad request\", status: 400 }\n);\nconst d = await r.json(); // will resolve as { error: string };\n</code></pre></p> <p>You can use <code>TypedResponse</code> to help unwrap the json type from a response object generated by <code>json()</code></p>"},{"location":"api/response/#redirect","title":"redirect","text":"<p>This will create a redirect response with both the http redirect headers as well as htmx headers. If you include the option <code>clientOnly == true</code> then it will omit the http redirect header, and instead will cause htmx to just navigate to the new page using boost (if present) <pre><code>import { redirect } from \"htmx-router/response\";\nconst r: Response = redirect(\"/place\", { clientOnly: true });\n</code></pre></p>"},{"location":"api/response/#revalidate","title":"revalidate","text":"<p>Short hand for <code>redirect(\"\", { clientOnly: true })</code> <pre><code>import { revalidate } from \"htmx-router/response\";\nconst r: Response = revalidate();\n</code></pre></p>"},{"location":"api/response/#refresh","title":"refresh","text":"<p>Similar to redirect except it doesn't navigate the page, and instead relies on http-refresh, and hx-refresh instead. <pre><code>import { refresh } from \"htmx-router/response\";\nconst r: Response = refresh();\n</code></pre></p>"},{"location":"api/shell/","title":"Shell API","text":"<p>This includes helpers to parse html, opengraph, and json+ld metadata up the shell chain to be rendered at the root.</p> <pre><code>import { ShellOptions, ApplyMetaDefaults } from \"htmx-router/shell\";\nimport * as root from \"~/routes/$.tsx\";\n\nexport function shell(inner: JSX.Element, options: ShellOptions&lt;{ somethingExtra: Data }&gt;) {\n  // do stuff that I care about with options.somethingExtra\n\n  // will add these attributes to options if not present\n  // does this is not applied deeply, and instead is only a shallow copy\n  ApplyMetaDefaults(options, { title: \"Place\", description: \"we do things here\" });\n\n  return root.shell(inner, options);\n}\n</code></pre> <p>It also includes a <code>RenderMetaDescriptors</code> function which will take a <code>ShellOptions</code> object and render the meta tags directly to a string so they are agnostic of JSX templating, it is recommended that you use the <code>&lt;Head&gt;</code> component to render them into the final html.</p>"},{"location":"api/status/","title":"Status API","text":"<p>A helper for determining a status text from code and visa versa.</p>"},{"location":"api/status/#makestatus","title":"MakeStatus","text":"<p>For returning plain text as a response <pre><code>import { MakeStatus } from \"htmx-router/response\";\n\nMakeStatus(\"I'm a teaPot\"); // { status: 418, statusText: \"I'm a teapot\" }\nMakeStatus(301);            // { status: 301, statusText: \"Moved Permanently\" }\n</code></pre></p>"},{"location":"components/","title":"Components","text":"<p>To bring any of these components into your project you must specify where they should be stored in your <code>htmx.config.json</code>, then run <code>npx htmx-router</code> for it to generate the files.</p> htmx.config.json<pre><code>{\n    \"framework\": \"react\",\n    \"component\": {\n        \"defer\":   \"./app/component/defer.tsx\",\n        \"head\":    \"./app/component/head.tsx\",\n        \"scripts\": \"./app/component/scripts.tsx\"\n    }\n}\n</code></pre>"},{"location":"components/defer/","title":"Defer Component","text":"<p>This component takes a deferral function and parameters and will lazily load it's content once mounted to the client page. This can be useful for dynamic content on a relatively static page, such as a profile badge.</p> <pre><code>&lt;Defer loader={profile} params={{ someThingUniqueTo: \"this placement\" }}/&gt;\n</code></pre> <p>Warning</p> <p>Don't forget to register your deferred function before use</p>"},{"location":"components/head/","title":"Head Component","text":"<p>A helper to take your shell options and render them straight into the head.</p> Example Usage<pre><code>&lt;html&gt;\n  &lt;Head options={options}&gt;\n    &lt;meta name=\"theme-color\" content=\"#fff\" /&gt;\n    &lt;Scripts /&gt;\n  &lt;/Head&gt;\n  &lt;body&gt;\n    {inner}\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"components/scripts/","title":"Scripts Component","text":"<p>This component will automatically create the header tags to import the required client side code to operate including your <code>entry.client.ts</code> as well as the css sheet generated by the <code>new Style</code>s.</p> <pre><code>&lt;Scripts /&gt;\n</code></pre>"},{"location":"island/","title":"Islands","text":"<p>Island are a way of rendering content out of directly by the server in the response.</p> <p>Server islands are a way to lazy load dynamic content on a mostly static page allowing the base page to be cached universally (not specific to a session) - and client islands to parse data to the browser to render the component on the client for higher interactivity.</p>"},{"location":"island/client/","title":"Client Island","text":"<p>A client island is a component which is mounted and rendered on the client side, but can also have a pre-rendered placeholder generated by the server.</p> <p>Before a component can be used on the client you must first reference it in the <code>/app/manifest.tsx</code>, simply import the class to that file and the vite plugin will do the reset, however we also recommend exporting the component itself direct to prevent typescript from complaining.</p> <pre><code>import type { ClientIslandManifest } from \"htmx-router\";\n\nimport { TimeSince } from \"~/component/client/time\";\nconst Client = {\n    TimeSince\n};\n\nexport default Client as ClientIslandManifest&lt;typeof Client&gt;;\n</code></pre> <p>Once the component is referenced in the manifest you must use it from the manifest for it to be re-rendered on the client. <pre><code>import Client from \"~/manifest.tsx\";\n\nexport function loader() {\n  return &lt;Client.TimeSince time={Date.now()}&gt;\n    A server rendered placeholder that will be replaced once the client mounts\n  &lt;/Client.TimeSince&gt;\n}\n</code></pre></p>"},{"location":"island/client/#client-mounting","title":"Client Mounting","text":"<p>You must also import the manifest in your <code>entry.client.ts</code> or else the components will never mount. entry.client.ts<pre><code>import \"~/manifest\";\n\n// ... the rest of your entry\n\n// vite complains if the client entry doesn't have a default export\nexport default {};\n</code></pre></p>"},{"location":"island/client/#static-generation","title":"Static Generation","text":"<p>If you define the client in your <code>htmx.config.json</code> you can have it statically generate the server and client versions of the manifest which you can import directly instead of relying on the vite plugin.</p> htmx.config.json<pre><code>{\n  \"framework\": \"react\",\n  \"client\": {\n    \"source\": \"./app/manifest.tsx\",\n    \"output\": {\n      \"server\": \"./app/manifest.server.tsx\",\n      \"client\": \"./app/manifest.client.tsx\",\n    }\n  }\n}\n</code></pre>"},{"location":"island/preservation/","title":"Island Perseveration","text":"<p>But how to I stop my defer from reloading, and my client island from remounting each time I use htmx boost, or re-render a partial using a htmx fetcher?</p> <p>Just wrap it in a hx-preserve <pre><code>&lt;div id=\"profile\" hx-preserve=\"true\"&gt;\n  &lt;Defer loader={profile}&gt;\n    A skeleton I could define\n  &lt;/Defer&gt;\n&lt;/div&gt;\n</code></pre></p>"},{"location":"island/server/","title":"Server Island","text":"<p>To create a server island simply use the <code>&lt;Defer/&gt;</code> to lazily load a html partial once the page is mounted. You can optionally define a skeleton which will be replaced once the deferred component has been loaded.</p> <p>This can be useful for mostly static pages allowing them to be cached and only the dynamic content is generated later after the browser has loaded the cached page from a CDN.</p> <pre><code>&lt;Defer loader={profile}&gt;\n  A skeleton I could define\n&lt;/Defer&gt;\n</code></pre>"},{"location":"router/","title":"Router","text":"<p>The router will perform a depth first search until it hits an endpoint trying this options at each branch   1. Resolve Index   2. Resolve Next   3. Resolve Wildcard   4. Resolve Slug</p> <p>The best way to illustrate this is through an example <pre><code>routes\n\u251c\u2500 post\n\u2502  \u2514\u2500 $postID.tsx\n\u251c\u2500 user\n\u2502  \u251c\u2500 $userID\n\u2502  \u2502  \u251c\u2500 _index.tsx\n\u2502  \u2502  \u2514\u2500 edit.tsx\n\u2502  \u251c\u2500 _index.tsx\n\u2502  \u2514\u2500 $.tsx\n\u251c\u2500 _index.tsx\n\u2514\u2500  $.tsx\n</code></pre></p> Url Path Resolved File <code>/</code> <code>./routes/_index.tsx</code> <code>/post/3</code> <code>./routes/post/postID.tsx</code> <code>/user</code> <code>./routes/user/_index.tsx</code> <code>/user/1</code> <code>./routes/user/$userID/_index.tsx</code> <code>/user/1/edit</code> <code>./routes/user/$userID/edit.tsx</code> <p>When a path resolves to a particular file it will try and call the <code>loader</code> function if the method is <code>GET</code> or <code>HEAD</code> and all other methods will try and call the <code>action</code> function, if the function is not defined it is treated as if the route doesn't exist and will continue the search.</p> <p>The <code>loader</code> and <code>action</code> functions can also return <code>null</code> which cause the router to continue the search meaning you can allow fallthrough to a slug endpoint from others. For instances if <code>./routes/user/$userID/_index.tsx</code> returned <code>null</code> it would then try <code>./routes/user/$.tsx</code>.</p> <p>Similarly if a route throws an error or returns a <code>Response</code> with a bad status code, it will try and parse that value to the <code>error</code> function of that file, and if it's not present it will back-track up the tree attempt to give the error to a slug's (<code>$.tsx</code>) error function.</p> <p>The only exception is if you return a response object which includes the header <code>X-Caught</code>, in which case it will not be fed into an <code>error</code> function and instead will return up as the actual response.</p> Example route<pre><code>export async function loader(ctx: RouteContext) {\n  return text(\"I was loaded\");\n}\n\nexport async function action(ctx: RouteContext) {\n  return text(\"I was posted\");\n}\n\nexport async function error(ctx: RouteContext, e: unknown) {\n    const message = await ErrorBody(e)\n\n    return &lt;html lang=\"en\" &gt;\n    &lt;Head options={{}}&gt;\n        { headers }\n        &lt;Scripts /&gt;\n    &lt;/Head&gt;\n    &lt;body&gt;\n        {message}\n    &lt;/body&gt;\n&lt;/html&gt;;\n}\n\nasync function ErrorBody(error: unknown) {\n    if (error instanceof Response) {\n        return &lt;&gt;\n            &lt;h1 style={{ marginTop: 0 }}&gt;{error.status} {error.statusText}&lt;/h1&gt;\n            &lt;p&gt;{await error.text()}&lt;/p&gt;\n        &lt;/&gt;\n    }\n\n    if (error instanceof Error) {\n        console.error(error);\n        return &lt;&gt;\n            &lt;h1 style={{ marginTop: 0 }}&gt;Error&lt;/h1&gt;\n            &lt;p&gt;{error.message}&lt;/p&gt;\n            &lt;p&gt;Stack trace&lt;/p&gt;\n            &lt;pre&gt;{error.stack}&lt;/pre&gt;\n        &lt;/&gt;\n    }\n\n    return &lt;&gt;\n        &lt;h1 style={{ marginTop: 0 }}&gt;Error&lt;/h1&gt;\n    &lt;/&gt;\n}\n</code></pre>"},{"location":"router/nesting/","title":"Route Nesting","text":"<p>In other routers, route nesting is typically top down, meaning the parent route will render, then use an <code>&lt;Outlet/&gt;</code> or some other means to embed the child route's body within itself. However this can create an issue because the parent doesn't know what child may be rendered in it, so it can't reliably parse data into the child so you end up with duplicate db lookups, and permission checks.</p> <p>Instead htmx-router relies on inverting that with what we call slug shelling. Where you define a slug route (which may have no actual endpoints), but it exports a shell function, which is given any data it needs that it's child will have already loaded, as well as the child's body. You can then chain multiple slugs together to create deeply nested routes.</p> routes/$userID/$.tsx<pre><code>import * as parent from \"~/routes/$.tsx\";\n\nexport function shell(inner: JSX.Element, props: ShellOptions&lt;{ user: { id: number, name: string }}&gt;) {\n  return parent.shell(&lt;div&gt;\n    Hello user &lt;a href={`/user/${props.user.id}`}&gt;&lt;/a&gt;\n    {inner}\n  &lt;/div&gt;, props);\n}\n</code></pre> <p>This reverse nesting means it is up to the child whether or not it wants to be nested in the parent, meaning you can easily create new routes for html partials with no, or only part inheritance.</p> <p>SlugOptions also includes the ability to add metadata for generating a page's meta-tags for the final render.</p>"},{"location":"router/parameters/","title":"Route Parameters","text":"<p>A route can optionally export a <code>parameters</code> object, which is a <code>Record</code> of parameter names, paired with functions to safely decode them from the url string. If this object is exported the router will attempt to parse the params before calling the <code>loader</code> or <code>action</code> function, meaning for those functions to be called the url parameters must be valid.</p> <pre><code>export const parameters = {\n  kind: (s: string) =&gt; {\n    if (s !== \"user\" &amp;&amp; s !== \"group\") throw new Response(\"invalid kind\", { status: 400, statusText: \"Bad Request\" });\n    return s;\n  },\n  id: Number\n}\n\nexport async function loader({ params }: RouteContext&lt;typeof parameters&gt;) {\n  // no type errors here, because they are of these types exactly\n  const kind : \"user\" | \"group\" = params.kind;\n  const id   : number           = params.number;\n}\n</code></pre> <p>The route context also includes:</p> Key Description <code>request</code> Request the original request object <code>url</code> The already parsed URL object of the request <code>cookie</code> The Cookies from the request, and set cookies will be added to the final response <code>headers</code> A header object that will be merged with the final response allowing early header setting <code>params</code> This object will be empty if no <code>parameters</code> object is exported"},{"location":"setup/","title":"Setup","text":"<p>The setup for this router is slightly more involved than most other routers because it exposes a lot of it's internals to make it adaptable to your project and it's needs, but it also means you need to connect a few hoses before it can start running.</p> <p>Because of that we've broken it up into three sections: vite, server, and rendering.</p>"},{"location":"setup/client/","title":"Client Setup","text":"<p>You must ensure that a version of htmx is loaded on all pages rendered by the router, or else some features will not work.</p>"},{"location":"setup/config/","title":"Config Setup (optional)","text":"<p>You can optionally define a <code>htmx.config.json</code> which needs to specify which framework you are using, and can then also define extra properties for client islands, and for building the pre-made htmx-router components for your framework.</p> <p>The current structure of this config is as follows: htmx.config.json type<pre><code>type Config = {\n    framework: \"react\" | \"generic\" | string,\n    client?: {\n        source: string,\n        output: {\n            server: string,\n            client: string\n        }\n    }\n    component?: Record&lt;string, string&gt;\n}\n</code></pre></p>"},{"location":"setup/server/","title":"Server Setup","text":"<p>Finally you just need something to actually give the router http requests, this can be in the form of a <code>http.IncomingMessage</code> or a <code>Request</code> object for the router to process.</p> server.js<pre><code>import { renderToString } from 'react-dom/server';\nimport express from 'express';\n\n\n// create the vite server\nconst viteDevServer = isProduction ? null\n  : await import(\"vite\").then((vite) =&gt;\n    vite.createServer({\n      server: { middlewareMode: true },\n      appType: 'custom'\n    })\n  );\n\n// expose assets generated for the client by the server and client builds\nconst app = express();\nif (isProduction) {\n  app.use(express.static(\"./dist/client\"));\n  app.use(\"/dist/asset\", express.static(\"./dist/server/dist/asset\"));\n}\n\n// load your server entry\nconst build = viteDevServer\n  ? () =&gt; viteDevServer.ssrLoadModule('./app/entry.server.ts')\n  : await import('./dist/server/entry.server.js');\n\nimport { createHtmxServer } from 'htmx-router/server';\nconst htmx = createHtmxServer({\n  build, viteDevServer,\n  render: renderToString /* (1) */\n});\n\n// bind to htmx-router\napp.use('*', htmx.nodeAdaptor(true));\n\n// Start http server\nconst port = process.env.PORT || 3000;\napp.listen(port, () =&gt; {\n  console.log(`Server started at http://localhost:${port}`)\n});\n</code></pre> <ol> <li>Any function that takes a <code>JSX.Element</code> and returns a <code>string</code> will suffice</li> </ol> <p>If you aren't using express, and say using something more like deno's native http server you would use <code>createRequestHandler.native</code> instead: <pre><code>export default {\n  async fetch (req) {\n    const route: Response | null = await htmx.resolve(req, false);\n    if (route) return route;\n\n    // do some other static file serving\n\n    return htmx.error(req); // no error will create a 404\n  }\n} satisfies Deno.ServeDefaultExport\n</code></pre></p>"},{"location":"setup/server/#helpful-extras","title":"Helpful extras","text":"<p>Here are a couple of helpful extras you could add to your <code>server.js</code></p>"},{"location":"setup/server/#reload-on-server-code-change","title":"Reload on server code change","text":"<pre><code>import * as path from \"path\";\nif (viteDevServer) {\n  const focus = path.resolve(\"./app\");\n  viteDevServer.watcher.on('change', (file) =&gt; {\n    if (!file.startsWith(focus)) return;\n    console.log(`File changed: ${file}`);\n\n    console.log('Triggering full page reload');\n    viteDevServer.ws.send({ type: 'full-reload' });\n  });\n}\n</code></pre>"},{"location":"setup/server/#graceful-shutdown","title":"Graceful shutdown","text":"<pre><code>const shutdown = () =&gt; {\n  console.log(\"Shutting down server...\");\n\n  // Close the server gracefully\n  app.close((err) =&gt; {\n    if (err) {\n      console.error(\"Error during server shutdown:\", err);\n      process.exit(1);\n    }\n    console.log(\"Server shut down gracefully.\");\n    process.exit(0);\n  });\n};\n\nprocess.on('SIGTERM', shutdown);\nprocess.on('SIGHUP', shutdown);\n</code></pre>"},{"location":"setup/vite/","title":"Vite Setup","text":"<p>The biggest requirement is a vite setup that generates SSR manifests so the server knows what client chunks are generated so it can reference them.</p> vite.config.ts<pre><code>import { defineConfig, UserConfig } from \"vite\";\nexport default defineConfig({\n  ssr: {\n    noExternal: ['vite'],\n  },\n  build: {\n    target: \"esnext\",\n    rollupOptions: {\n      input: 'app/entry.client.ts'\n    },\n    outDir: 'dist/client',\n    assetsDir: 'dist/asset',\n    ssrEmitAssets: true,\n    manifest: true\n  },\n  plugins: []\n});\n</code></pre> <p>The second requirement is that you define a client, and server entry point for compilation to work effectively</p> app/entry.server.ts<pre><code>import { GenerateRouteTree } from 'htmx-router/router';\nexport const tree = GenerateRouteTree({\n  modules: import.meta.glob('./routes/**/*.{ts,tsx}', { eager: true }),\n  scope: \"./routes\",\n});\n</code></pre> app/entry.client.ts<pre><code>// vite complains if the client entry doesn't have a default export\nexport default {};\n</code></pre>"},{"location":"setup/vite/#plugins","title":"Plugins","text":"<p>There are also two optional plugins provided by htmx-router for vite, with both being optional, however <code>ClientIsland</code> is required if you plan on using client islands</p> vite.config.ts<pre><code>import { BundleSplitter, ClientIsland } from \"htmx-router/vite\";\nimport { defineConfig, UserConfig } from \"vite\";\nexport default defineConfig({\n  // same as before\n  plugins: [\n        ClientIsland(\"react\"),\n        BundleSplitter()\n    ],\n});\n</code></pre> <p>We also recommend using tsconfig paths to make <code>~</code> resolve to <code>./app/</code>, that way as you move your route files around you do not have to change your relative imports.</p> tsconfig.json<pre><code>{\n    \"compilerOptions\": {\n        \"paths\": { \"~/*\": [\"./app/*\"] },\n        \"noEmit\": true // Vite takes care of building everything, not tsc\n    }\n}\n</code></pre>"},{"location":"setup/vite/#bundle-splitter","title":"Bundle Splitter","text":"<p>The bundle splitter will omit certain code from the client and server builds, if a file ends with <code>.client.tsx</code> (also supports <code>.ts</code>, <code>.js</code> <code>.jsx</code>) then it will be omitted from the server bundled, and likewise if it ends with <code>.server.tsx</code> for the client.</p> <p>This can be helpful to ensure certain code never leaks into the client. Or that expensive client side rendering for interactivity it processed on the server.</p>"},{"location":"setup/vite/#client-island","title":"Client Island","text":"<p>This plugin will intercept imports for your <code>app/manifest.tsx</code> within vite and instead will import either the server side hydration code, or the client side manifest for hydration based on which mode is being built.</p>"},{"location":"setup/vite/#build-scripts","title":"Build Scripts","text":"<p>Since there is a client and a server build being generated, we recommend making a build setup like below so everything can be streamlined</p> package.json<pre><code>{\n    \"type\": \"module\",\n    \"scripts\": {\n        \"prepare\": \"npx htmx-router\",\n        \"dev\": \"node ./server.js\",\n        \"build\": \"run-s build:*\",\n        \"build:client\": \"vite build\",\n        \"build:server\": \"vite build --ssr app/entry.server.ts --outDir dist/server\",\n        \"preview\": \"cross-env NODE_ENV=production node ./server.js\"\n    }\n}\n</code></pre>"}]}